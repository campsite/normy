{"version":3,"file":"normy-swr.js","mappings":"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,UAAAC,KAAK,EAAI;UAC/B,KAAKV,MAAM,CAACU,KAAK,CAACC,QAAQ,EAAED,KAAK,CAACJ,IAAI,EAAE;YACtCM,UAAU,EAAE;UACd,CAAC,CAAC;QACJ,CAAC,CAAC;MACJ;MAEA,OAAOwD,OAAO,YAAPA,OAAO,CAAES,OAAO,oBAAhBT,OAAO,CAAES,OAAO,CAAGC,KAAK,EAAEJ,WAAW,EAAEC,MAAM,CAAC;IACvD;EAAC,EAEL,CAAC;AACH,CAAC;;;;;;;;;;ACzID;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAqH;;AAErH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,YAAY;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,wCAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,4CAAS,GAAG,kDAAe;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,MAAM,aAAa;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,sBAAsB;AACtB,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wBAAwB;AACxC,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,oDAAa,GAAG;AACzC;AACA,YAAY,QAAQ;AACpB,yBAAyB,iDAAU;AACnC;AACA,mBAAmB,8CAAO;AAC1B;AACA;AACA;AACA;AACA;AACA,2BAA2B,8CAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6CAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,WAAW,oDAAa;AACxB;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kCAAK;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,iDAAU;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA,uCAAuC,IAAI;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEgiB;;;;;;;;;;;;;;;;;;AClqBne;AAClB;AACkG;;AAE7I,wBAAwB,yDAAe;AACvC;AACA,EAAE,EAAE,kDAAqB;AACzB;AACA;AACA;AACA,yBAAyB,+CAAQ,GAAG;AACpC,yBAAyB,6CAAM;AAC/B,qBAAqB,6CAAM;AAC3B;AACA;AACA;AACA;AACA,iCAAiC,6CAAM;AACvC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,uBAAuB,kDAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,KAAK;AACL,IAAI,uEAAyB;AAC7B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA,+CAA+C;AAC/C,gBAAgB,SAAS,EAAE,iDAAY;AACvC,uBAAuB,6CAAM;AAC7B,2BAA2B,6CAAM;AACjC,0BAA0B,6CAAM;AAChC;AACA,uCAAuC,6CAAM;AAC7C;AACA,kBAAkB,mDAAS;AAC3B,mBAAmB,mDAAS;AAC5B;AACA,SAAS;AACT;AACA,wBAAwB,kDAAW;AACnC,iDAAiD,uDAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0DAAY,CAAC,0DAAY;AACrD;AACA;AACA,aAAa;AACb;AACA;AACA,sCAAsC,0DAAY;AAClD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB,0DAAY;AAC5B;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sBAAsB,kDAAW;AACjC,6CAA6C,0DAAY;AACzD;AACA,sBAAsB,mDAAS;AAC/B,uBAAuB,mDAAS;AAChC;AACA,aAAa;AACb;AACA,SAAS;AACT,QAAQ,uEAAyB;AACjC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,2BAA2B,4DAAc,CAAC,gCAAM;;AAEX;;;;;;;UC/LrC;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;;;;;;ACNoC;AAKH","sources":["webpack://NormySwr/webpack/universalModuleDefinition","webpack://NormySwr/./src/SWRNormalizerProvider.tsx","webpack://NormySwr/./src/useNormalizedSWRMutation.ts","webpack://NormySwr/external umd {\"commonjs\":\"@normy/core\",\"commonjs2\":\"@normy/core\",\"amd\":\"@normy/core\",\"root\":\"Normy\"}","webpack://NormySwr/external umd {\"commonjs\":\"react\",\"commonjs2\":\"react\",\"amd\":\"react\",\"root\":\"React\"}","webpack://NormySwr/external umd {\"commonjs\":\"swr\",\"commonjs2\":\"swr\",\"amd\":\"swr\",\"root\":\"Swr\"}","webpack://NormySwr/../../node_modules/.pnpm/swr@2.2.4_react@18.2.0/node_modules/swr/_internal/dist/index.mjs","webpack://NormySwr/../../node_modules/.pnpm/swr@2.2.4_react@18.2.0/node_modules/swr/mutation/dist/index.mjs","webpack://NormySwr/webpack/bootstrap","webpack://NormySwr/webpack/runtime/compat get default export","webpack://NormySwr/webpack/runtime/define property getters","webpack://NormySwr/webpack/runtime/hasOwnProperty shorthand","webpack://NormySwr/webpack/runtime/make namespace object","webpack://NormySwr/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"@normy/core\"), require(\"react\"), require(\"swr\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"@normy/core\", \"react\", \"swr\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"NormySwr\"] = factory(require(\"@normy/core\"), require(\"react\"), require(\"swr\"));\n\telse\n\t\troot[\"NormySwr\"] = factory(root[\"Normy\"], root[\"React\"], root[\"Swr\"]);\n})(self, (__WEBPACK_EXTERNAL_MODULE__normy_core__, __WEBPACK_EXTERNAL_MODULE_react__, __WEBPACK_EXTERNAL_MODULE_swr__) => {\nreturn ","import * as React from 'react';\nimport {\n  type NormalizerConfig,\n  createNormalizer,\n  type Data,\n} from '@normy/core';\nimport { useSWRConfig, SWRConfig, type Key } from 'swr';\n\nconst createSwrNormalizer = (\n  normalizerConfig: Omit<NormalizerConfig, 'structuralSharing'> & {\n    normalize?: (queryKey: string) => boolean;\n  } = {},\n) => {\n  const normalizer = createNormalizer(normalizerConfig);\n  // we solve chicken egg problem this way, we need normalizer to create swr context, and we cannot have mutate before it is created\n  let mutate: ReturnType<typeof useSWRConfig>['mutate'] | null = null;\n\n  return {\n    ...normalizer,\n    addMutate: (mutateCallback: ReturnType<typeof useSWRConfig>['mutate']) => {\n      mutate = mutateCallback;\n    },\n    normalize: normalizerConfig.normalize,\n    setNormalizedData: (data: Data) => {\n      const queriesToUpdate = normalizer.getQueriesToUpdate(data);\n\n      queriesToUpdate.forEach(query => {\n        void mutate?.(query.queryKey, query.data, {\n          revalidate: false,\n        });\n      });\n    },\n  };\n};\n\nconst SWRNormalizerContext = React.createContext<\n  undefined | ReturnType<typeof createSwrNormalizer>\n>(undefined);\n\nclass CacheMap extends Map {\n  normalizer: ReturnType<typeof createSwrNormalizer> | undefined;\n\n  addNormalizer(normalizer: ReturnType<typeof createSwrNormalizer>) {\n    this.normalizer = normalizer;\n  }\n\n  set(key: string, value: { data?: Data }) {\n    if (value.data && (this.normalizer?.normalize?.(key) ?? true)) {\n      this.normalizer?.setQuery(key, value.data);\n    }\n\n    return super.set(key, value);\n  }\n\n  delete(key: string) {\n    this.normalizer?.removeQuery(key);\n    return super.delete(key);\n  }\n}\n\nconst SWRNormalizerProviderInternal = ({\n  swrNormalizer,\n  children,\n}: {\n  swrNormalizer: ReturnType<typeof createSwrNormalizer>;\n  children: React.ReactNode;\n}) => {\n  const { mutate } = useSWRConfig();\n\n  React.useEffect(() => swrNormalizer.addMutate(mutate), []);\n\n  return (\n    <SWRNormalizerContext.Provider value={swrNormalizer}>\n      {children}\n    </SWRNormalizerContext.Provider>\n  );\n};\n\nexport const SWRNormalizerProvider = ({\n  normalizerConfig,\n  swrConfigValue,\n  children,\n}: {\n  normalizerConfig?: Omit<NormalizerConfig, 'structuralSharing'> & {\n    normalize: (queryKey: Key) => boolean;\n  };\n  swrConfigValue: React.ComponentProps<typeof SWRConfig>['value'];\n  children: React.ReactNode;\n}) => {\n  const [swrNormalizer] = React.useState(() =>\n    createSwrNormalizer(normalizerConfig),\n  );\n\n  const [cacheProvider] = React.useState(() => () => {\n    const map = new CacheMap();\n    map.addNormalizer(swrNormalizer);\n    return map;\n  });\n\n  React.useEffect(() => () => swrNormalizer.clearNormalizedData(), []);\n\n  return (\n    <SWRConfig\n      value={{\n        ...swrConfigValue,\n        provider: cacheProvider,\n      }}\n    >\n      <SWRNormalizerProviderInternal swrNormalizer={swrNormalizer}>\n        {children}\n      </SWRNormalizerProviderInternal>\n    </SWRConfig>\n  );\n};\n\nexport const useSWRNormalizer = () => {\n  const swrNormalizer = React.useContext(SWRNormalizerContext);\n\n  if (!swrNormalizer) {\n    throw new Error(\n      'No SWRNormalizer set, use SWRNormalizerProvider to set one',\n    );\n  }\n\n  return swrNormalizer;\n};\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { Data as NormyData } from '@normy/core';\nimport { useSWRConfig, type Key } from 'swr';\nimport useSWRMutation, {\n  type MutationFetcher,\n  type SWRMutationConfiguration,\n  type SWRMutationResponse,\n} from 'swr/mutation';\n\nimport { useSWRNormalizer } from './SWRNormalizerProvider';\n\ntype NormyOptions = {\n  normalize?: boolean;\n  optimisticData?: NormyData;\n  rollbackData?: NormyData;\n};\n\ninterface NormalizedSWRMutationHook {\n  <\n    Data = any,\n    Error = any,\n    SWRMutationKey extends Key = Key,\n    ExtraArg = never,\n    SWRData = Data,\n  >(\n    key: SWRMutationKey,\n    fetcher: MutationFetcher<Data, SWRMutationKey, ExtraArg>,\n    options?: SWRMutationConfiguration<\n      Data,\n      Error,\n      SWRMutationKey,\n      ExtraArg,\n      SWRData\n    > &\n      NormyOptions,\n  ): SWRMutationResponse<Data, Error, SWRMutationKey, ExtraArg>;\n  <\n    Data = any,\n    Error = any,\n    SWRMutationKey extends Key = Key,\n    ExtraArg = never,\n    SWRData = Data,\n  >(\n    key: SWRMutationKey,\n    fetcher: MutationFetcher<Data, SWRMutationKey, ExtraArg>,\n    options?: SWRMutationConfiguration<\n      Data,\n      Error,\n      SWRMutationKey,\n      ExtraArg,\n      SWRData\n    > & { throwOnError: false } & NormyOptions,\n  ): SWRMutationResponse<Data | undefined, Error, SWRMutationKey, ExtraArg>;\n  <\n    Data = any,\n    Error = any,\n    SWRMutationKey extends Key = Key,\n    ExtraArg = never,\n    SWRData = Data,\n  >(\n    key: SWRMutationKey,\n    fetcher: MutationFetcher<Data, SWRMutationKey, ExtraArg>,\n    options?: SWRMutationConfiguration<\n      Data,\n      Error,\n      SWRMutationKey,\n      ExtraArg,\n      SWRData\n    > & { throwOnError: true } & NormyOptions,\n  ): SWRMutationResponse<Data, Error, SWRMutationKey, ExtraArg>;\n}\n\nexport const useNormalizedSWRMutation: NormalizedSWRMutationHook = (\n  key,\n  fetcher,\n  options,\n) => {\n  const { mutate } = useSWRConfig();\n  const normalizer = useSWRNormalizer();\n\n  return useSWRMutation(\n    key,\n    // @ts-expect-error swr types compatiblity issue, perhaps due to ts version mismatch\n    (k, opts) => {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n      if (options?.optimisticData) {\n        const queriesToUpdate = normalizer.getQueriesToUpdate(\n          options?.optimisticData as NormyData,\n        );\n\n        queriesToUpdate.forEach(query => {\n          void mutate(query.queryKey, query.data, {\n            revalidate: false,\n          });\n        });\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n      return fetcher(k, opts);\n    },\n    {\n      populateCache: false,\n      revalidate: false,\n      ...options,\n      optimisticData: undefined,\n      onSuccess: (data, mutationKey, config) => {\n        if (options?.normalize ?? true) {\n          const queriesToUpdate = normalizer.getQueriesToUpdate(\n            data as NormyData,\n          );\n\n          queriesToUpdate.forEach(query => {\n            void mutate(query.queryKey, query.data, {\n              revalidate: false,\n            });\n          });\n        }\n\n        return options?.onSuccess?.(data, mutationKey, config);\n      },\n      onError: (error, mutationKey, config) => {\n        if (options?.rollbackData) {\n          const queriesToUpdate = normalizer.getQueriesToUpdate(\n            options?.rollbackData as NormyData,\n          );\n\n          queriesToUpdate.forEach(query => {\n            void mutate(query.queryKey, query.data, {\n              revalidate: false,\n            });\n          });\n        }\n\n        return options?.onError?.(error, mutationKey, config);\n      },\n    },\n  );\n};\n","module.exports = __WEBPACK_EXTERNAL_MODULE__normy_core__;","module.exports = __WEBPACK_EXTERNAL_MODULE_react__;","module.exports = __WEBPACK_EXTERNAL_MODULE_swr__;","import React, { useEffect, useLayoutEffect, createContext, useContext, useMemo, useRef, createElement } from 'react';\n\n// Shared state between server components and client components\nconst noop = ()=>{};\n// Using noop() as the undefined value as undefined can be replaced\n// by something else. Prettier ignore and extra parentheses are necessary here\n// to ensure that tsc doesn't remove the __NOINLINE__ comment.\n// prettier-ignore\nconst UNDEFINED = /*#__NOINLINE__*/ noop();\nconst OBJECT = Object;\nconst isUndefined = (v)=>v === UNDEFINED;\nconst isFunction = (v)=>typeof v == 'function';\nconst mergeObjects = (a, b)=>({\n        ...a,\n        ...b\n    });\nconst isPromiseLike = (x)=>isFunction(x.then);\n\n// use WeakMap to store the object->key mapping\n// so the objects can be garbage collected.\n// WeakMap uses a hashtable under the hood, so the lookup\n// complexity is almost O(1).\nconst table = new WeakMap();\n// counter of the key\nlet counter = 0;\n// A stable hash implementation that supports:\n// - Fast and ensures unique hash properties\n// - Handles unserializable values\n// - Handles object key ordering\n// - Generates short results\n//\n// This is not a serialization function, and the result is not guaranteed to be\n// parsable.\nconst stableHash = (arg)=>{\n    const type = typeof arg;\n    const constructor = arg && arg.constructor;\n    const isDate = constructor == Date;\n    let result;\n    let index;\n    if (OBJECT(arg) === arg && !isDate && constructor != RegExp) {\n        // Object/function, not null/date/regexp. Use WeakMap to store the id first.\n        // If it's already hashed, directly return the result.\n        result = table.get(arg);\n        if (result) return result;\n        // Store the hash first for circular reference detection before entering the\n        // recursive `stableHash` calls.\n        // For other objects like set and map, we use this id directly as the hash.\n        result = ++counter + '~';\n        table.set(arg, result);\n        if (constructor == Array) {\n            // Array.\n            result = '@';\n            for(index = 0; index < arg.length; index++){\n                result += stableHash(arg[index]) + ',';\n            }\n            table.set(arg, result);\n        }\n        if (constructor == OBJECT) {\n            // Object, sort keys.\n            result = '#';\n            const keys = OBJECT.keys(arg).sort();\n            while(!isUndefined(index = keys.pop())){\n                if (!isUndefined(arg[index])) {\n                    result += index + ':' + stableHash(arg[index]) + ',';\n                }\n            }\n            table.set(arg, result);\n        }\n    } else {\n        result = isDate ? arg.toJSON() : type == 'symbol' ? arg.toString() : type == 'string' ? JSON.stringify(arg) : '' + arg;\n    }\n    return result;\n};\n\n// Global state used to deduplicate requests and store listeners\nconst SWRGlobalState = new WeakMap();\n\nconst EMPTY_CACHE = {};\nconst INITIAL_CACHE = {};\nconst STR_UNDEFINED = 'undefined';\n// NOTE: Use the function to guarantee it's re-evaluated between jsdom and node runtime for tests.\nconst isWindowDefined = typeof window != STR_UNDEFINED;\nconst isDocumentDefined = typeof document != STR_UNDEFINED;\nconst hasRequestAnimationFrame = ()=>isWindowDefined && typeof window['requestAnimationFrame'] != STR_UNDEFINED;\nconst createCacheHelper = (cache, key)=>{\n    const state = SWRGlobalState.get(cache);\n    return [\n        // Getter\n        ()=>!isUndefined(key) && cache.get(key) || EMPTY_CACHE,\n        // Setter\n        (info)=>{\n            if (!isUndefined(key)) {\n                const prev = cache.get(key);\n                // Before writing to the store, we keep the value in the initial cache\n                // if it's not there yet.\n                if (!(key in INITIAL_CACHE)) {\n                    INITIAL_CACHE[key] = prev;\n                }\n                state[5](key, mergeObjects(prev, info), prev || EMPTY_CACHE);\n            }\n        },\n        // Subscriber\n        state[6],\n        // Get server cache snapshot\n        ()=>{\n            if (!isUndefined(key)) {\n                // If the cache was updated on the client, we return the stored initial value.\n                if (key in INITIAL_CACHE) return INITIAL_CACHE[key];\n            }\n            // If we haven't done any client-side updates, we return the current value.\n            return !isUndefined(key) && cache.get(key) || EMPTY_CACHE;\n        }\n    ];\n} // export { UNDEFINED, OBJECT, isUndefined, isFunction, mergeObjects, isPromiseLike }\n;\n\n/**\n * Due to the bug https://bugs.chromium.org/p/chromium/issues/detail?id=678075,\n * it's not reliable to detect if the browser is currently online or offline\n * based on `navigator.onLine`.\n * As a workaround, we always assume it's online on the first load, and change\n * the status upon `online` or `offline` events.\n */ let online = true;\nconst isOnline = ()=>online;\n// For node and React Native, `add/removeEventListener` doesn't exist on window.\nconst [onWindowEvent, offWindowEvent] = isWindowDefined && window.addEventListener ? [\n    window.addEventListener.bind(window),\n    window.removeEventListener.bind(window)\n] : [\n    noop,\n    noop\n];\nconst isVisible = ()=>{\n    const visibilityState = isDocumentDefined && document.visibilityState;\n    return isUndefined(visibilityState) || visibilityState !== 'hidden';\n};\nconst initFocus = (callback)=>{\n    // focus revalidate\n    if (isDocumentDefined) {\n        document.addEventListener('visibilitychange', callback);\n    }\n    onWindowEvent('focus', callback);\n    return ()=>{\n        if (isDocumentDefined) {\n            document.removeEventListener('visibilitychange', callback);\n        }\n        offWindowEvent('focus', callback);\n    };\n};\nconst initReconnect = (callback)=>{\n    // revalidate on reconnected\n    const onOnline = ()=>{\n        online = true;\n        callback();\n    };\n    // nothing to revalidate, just update the status\n    const onOffline = ()=>{\n        online = false;\n    };\n    onWindowEvent('online', onOnline);\n    onWindowEvent('offline', onOffline);\n    return ()=>{\n        offWindowEvent('online', onOnline);\n        offWindowEvent('offline', onOffline);\n    };\n};\nconst preset = {\n    isOnline,\n    isVisible\n};\nconst defaultConfigOptions = {\n    initFocus,\n    initReconnect\n};\n\nconst IS_REACT_LEGACY = !React.useId;\nconst IS_SERVER = !isWindowDefined || 'Deno' in window;\n// Polyfill requestAnimationFrame\nconst rAF = (f)=>hasRequestAnimationFrame() ? window['requestAnimationFrame'](f) : setTimeout(f, 1);\n// React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser.\nconst useIsomorphicLayoutEffect = IS_SERVER ? useEffect : useLayoutEffect;\n// This assignment is to extend the Navigator type to use effectiveType.\nconst navigatorConnection = typeof navigator !== 'undefined' && navigator.connection;\n// Adjust the config based on slow connection status (<= 70Kbps).\nconst slowConnection = !IS_SERVER && navigatorConnection && ([\n    'slow-2g',\n    '2g'\n].includes(navigatorConnection.effectiveType) || navigatorConnection.saveData);\n\nconst serialize = (key)=>{\n    if (isFunction(key)) {\n        try {\n            key = key();\n        } catch (err) {\n            // dependencies not ready\n            key = '';\n        }\n    }\n    // Use the original key as the argument of fetcher. This can be a string or an\n    // array of values.\n    const args = key;\n    // If key is not falsy, or not an empty array, hash it.\n    key = typeof key == 'string' ? key : (Array.isArray(key) ? key.length : key) ? stableHash(key) : '';\n    return [\n        key,\n        args\n    ];\n};\n\n// Global timestamp.\nlet __timestamp = 0;\nconst getTimestamp = ()=>++__timestamp;\n\nconst FOCUS_EVENT = 0;\nconst RECONNECT_EVENT = 1;\nconst MUTATE_EVENT = 2;\nconst ERROR_REVALIDATE_EVENT = 3;\n\nvar events = {\n  __proto__: null,\n  ERROR_REVALIDATE_EVENT: ERROR_REVALIDATE_EVENT,\n  FOCUS_EVENT: FOCUS_EVENT,\n  MUTATE_EVENT: MUTATE_EVENT,\n  RECONNECT_EVENT: RECONNECT_EVENT\n};\n\nasync function internalMutate(...args) {\n    const [cache, _key, _data, _opts] = args;\n    // When passing as a boolean, it's explicitly used to disable/enable\n    // revalidation.\n    const options = mergeObjects({\n        populateCache: true,\n        throwOnError: true\n    }, typeof _opts === 'boolean' ? {\n        revalidate: _opts\n    } : _opts || {});\n    let populateCache = options.populateCache;\n    const rollbackOnErrorOption = options.rollbackOnError;\n    let optimisticData = options.optimisticData;\n    const revalidate = options.revalidate !== false;\n    const rollbackOnError = (error)=>{\n        return typeof rollbackOnErrorOption === 'function' ? rollbackOnErrorOption(error) : rollbackOnErrorOption !== false;\n    };\n    const throwOnError = options.throwOnError;\n    // If the second argument is a key filter, return the mutation results for all\n    // filtered keys.\n    if (isFunction(_key)) {\n        const keyFilter = _key;\n        const matchedKeys = [];\n        const it = cache.keys();\n        for (const key of it){\n            if (// Skip the special useSWRInfinite and useSWRSubscription keys.\n            !/^\\$(inf|sub)\\$/.test(key) && keyFilter(cache.get(key)._k)) {\n                matchedKeys.push(key);\n            }\n        }\n        return Promise.all(matchedKeys.map(mutateByKey));\n    }\n    return mutateByKey(_key);\n    async function mutateByKey(_k) {\n        // Serialize key\n        const [key] = serialize(_k);\n        if (!key) return;\n        const [get, set] = createCacheHelper(cache, key);\n        const [EVENT_REVALIDATORS, MUTATION, FETCH, PRELOAD] = SWRGlobalState.get(cache);\n        const startRevalidate = ()=>{\n            const revalidators = EVENT_REVALIDATORS[key];\n            if (revalidate) {\n                // Invalidate the key by deleting the concurrent request markers so new\n                // requests will not be deduped.\n                delete FETCH[key];\n                delete PRELOAD[key];\n                if (revalidators && revalidators[0]) {\n                    return revalidators[0](MUTATE_EVENT).then(()=>get().data);\n                }\n            }\n            return get().data;\n        };\n        // If there is no new data provided, revalidate the key with current state.\n        if (args.length < 3) {\n            // Revalidate and broadcast state.\n            return startRevalidate();\n        }\n        let data = _data;\n        let error;\n        // Update global timestamps.\n        const beforeMutationTs = getTimestamp();\n        MUTATION[key] = [\n            beforeMutationTs,\n            0\n        ];\n        const hasOptimisticData = !isUndefined(optimisticData);\n        const state = get();\n        // `displayedData` is the current value on screen. It could be the optimistic value\n        // that is going to be overridden by a `committedData`, or get reverted back.\n        // `committedData` is the validated value that comes from a fetch or mutation.\n        const displayedData = state.data;\n        const currentData = state._c;\n        const committedData = isUndefined(currentData) ? displayedData : currentData;\n        // Do optimistic data update.\n        if (hasOptimisticData) {\n            optimisticData = isFunction(optimisticData) ? optimisticData(committedData, displayedData) : optimisticData;\n            // When we set optimistic data, backup the current committedData data in `_c`.\n            set({\n                data: optimisticData,\n                _c: committedData\n            });\n        }\n        if (isFunction(data)) {\n            // `data` is a function, call it passing current cache value.\n            try {\n                data = data(committedData);\n            } catch (err) {\n                // If it throws an error synchronously, we shouldn't update the cache.\n                error = err;\n            }\n        }\n        // `data` is a promise/thenable, resolve the final data first.\n        if (data && isPromiseLike(data)) {\n            // This means that the mutation is async, we need to check timestamps to\n            // avoid race conditions.\n            data = await data.catch((err)=>{\n                error = err;\n            });\n            // Check if other mutations have occurred since we've started this mutation.\n            // If there's a race we don't update cache or broadcast the change,\n            // just return the data.\n            if (beforeMutationTs !== MUTATION[key][0]) {\n                if (error) throw error;\n                return data;\n            } else if (error && hasOptimisticData && rollbackOnError(error)) {\n                // Rollback. Always populate the cache in this case but without\n                // transforming the data.\n                populateCache = true;\n                // Reset data to be the latest committed data, and clear the `_c` value.\n                set({\n                    data: committedData,\n                    _c: UNDEFINED\n                });\n            }\n        }\n        // If we should write back the cache after request.\n        if (populateCache) {\n            if (!error) {\n                // Transform the result into data.\n                if (isFunction(populateCache)) {\n                    const populateCachedData = populateCache(data, committedData);\n                    set({\n                        data: populateCachedData,\n                        error: UNDEFINED,\n                        _c: UNDEFINED\n                    });\n                } else {\n                    // Only update cached data and reset the error if there's no error. Data can be `undefined` here.\n                    set({\n                        data,\n                        error: UNDEFINED,\n                        _c: UNDEFINED\n                    });\n                }\n            }\n        }\n        // Reset the timestamp to mark the mutation has ended.\n        MUTATION[key][1] = getTimestamp();\n        // Update existing SWR Hooks' internal states:\n        Promise.resolve(startRevalidate()).then(()=>{\n            // The mutation and revalidation are ended, we can clear it since the data is\n            // not an optimistic value anymore.\n            set({\n                _c: UNDEFINED\n            });\n        });\n        // Throw error or return data\n        if (error) {\n            if (throwOnError) throw error;\n            return;\n        }\n        return data;\n    }\n}\n\nconst revalidateAllKeys = (revalidators, type)=>{\n    for(const key in revalidators){\n        if (revalidators[key][0]) revalidators[key][0](type);\n    }\n};\nconst initCache = (provider, options)=>{\n    // The global state for a specific provider will be used to deduplicate\n    // requests and store listeners. As well as a mutate function that is bound to\n    // the cache.\n    // The provider's global state might be already initialized. Let's try to get the\n    // global state associated with the provider first.\n    if (!SWRGlobalState.has(provider)) {\n        const opts = mergeObjects(defaultConfigOptions, options);\n        // If there's no global state bound to the provider, create a new one with the\n        // new mutate function.\n        const EVENT_REVALIDATORS = {};\n        const mutate = internalMutate.bind(UNDEFINED, provider);\n        let unmount = noop;\n        const subscriptions = {};\n        const subscribe = (key, callback)=>{\n            const subs = subscriptions[key] || [];\n            subscriptions[key] = subs;\n            subs.push(callback);\n            return ()=>subs.splice(subs.indexOf(callback), 1);\n        };\n        const setter = (key, value, prev)=>{\n            provider.set(key, value);\n            const subs = subscriptions[key];\n            if (subs) {\n                for (const fn of subs){\n                    fn(value, prev);\n                }\n            }\n        };\n        const initProvider = ()=>{\n            if (!SWRGlobalState.has(provider)) {\n                // Update the state if it's new, or if the provider has been extended.\n                SWRGlobalState.set(provider, [\n                    EVENT_REVALIDATORS,\n                    {},\n                    {},\n                    {},\n                    mutate,\n                    setter,\n                    subscribe\n                ]);\n                if (!IS_SERVER) {\n                    // When listening to the native events for auto revalidations,\n                    // we intentionally put a delay (setTimeout) here to make sure they are\n                    // fired after immediate JavaScript executions, which can be\n                    // React's state updates.\n                    // This avoids some unnecessary revalidations such as\n                    // https://github.com/vercel/swr/issues/1680.\n                    const releaseFocus = opts.initFocus(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, FOCUS_EVENT)));\n                    const releaseReconnect = opts.initReconnect(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, RECONNECT_EVENT)));\n                    unmount = ()=>{\n                        releaseFocus && releaseFocus();\n                        releaseReconnect && releaseReconnect();\n                        // When un-mounting, we need to remove the cache provider from the state\n                        // storage too because it's a side-effect. Otherwise, when re-mounting we\n                        // will not re-register those event listeners.\n                        SWRGlobalState.delete(provider);\n                    };\n                }\n            }\n        };\n        initProvider();\n        // This is a new provider, we need to initialize it and setup DOM events\n        // listeners for `focus` and `reconnect` actions.\n        // We might want to inject an extra layer on top of `provider` in the future,\n        // such as key serialization, auto GC, etc.\n        // For now, it's just a `Map` interface without any modifications.\n        return [\n            provider,\n            mutate,\n            initProvider,\n            unmount\n        ];\n    }\n    return [\n        provider,\n        SWRGlobalState.get(provider)[4]\n    ];\n};\n\n// error retry\nconst onErrorRetry = (_, __, config, revalidate, opts)=>{\n    const maxRetryCount = config.errorRetryCount;\n    const currentRetryCount = opts.retryCount;\n    // Exponential backoff\n    const timeout = ~~((Math.random() + 0.5) * (1 << (currentRetryCount < 8 ? currentRetryCount : 8))) * config.errorRetryInterval;\n    if (!isUndefined(maxRetryCount) && currentRetryCount > maxRetryCount) {\n        return;\n    }\n    setTimeout(revalidate, timeout, opts);\n};\nconst compare = (currentData, newData)=>stableHash(currentData) == stableHash(newData);\n// Default cache provider\nconst [cache, mutate] = initCache(new Map());\n// Default config\nconst defaultConfig = mergeObjects({\n    // events\n    onLoadingSlow: noop,\n    onSuccess: noop,\n    onError: noop,\n    onErrorRetry,\n    onDiscarded: noop,\n    // switches\n    revalidateOnFocus: true,\n    revalidateOnReconnect: true,\n    revalidateIfStale: true,\n    shouldRetryOnError: true,\n    // timeouts\n    errorRetryInterval: slowConnection ? 10000 : 5000,\n    focusThrottleInterval: 5 * 1000,\n    dedupingInterval: 2 * 1000,\n    loadingTimeout: slowConnection ? 5000 : 3000,\n    // providers\n    compare,\n    isPaused: ()=>false,\n    cache,\n    mutate,\n    fallback: {}\n}, // use web preset by default\npreset);\n\nconst mergeConfigs = (a, b)=>{\n    // Need to create a new object to avoid mutating the original here.\n    const v = mergeObjects(a, b);\n    // If two configs are provided, merge their `use` and `fallback` options.\n    if (b) {\n        const { use: u1, fallback: f1 } = a;\n        const { use: u2, fallback: f2 } = b;\n        if (u1 && u2) {\n            v.use = u1.concat(u2);\n        }\n        if (f1 && f2) {\n            v.fallback = mergeObjects(f1, f2);\n        }\n    }\n    return v;\n};\n\nconst SWRConfigContext = createContext({});\nconst SWRConfig = (props)=>{\n    const { value } = props;\n    const parentConfig = useContext(SWRConfigContext);\n    const isFunctionalConfig = isFunction(value);\n    const config = useMemo(()=>isFunctionalConfig ? value(parentConfig) : value, [\n        isFunctionalConfig,\n        parentConfig,\n        value\n    ]);\n    // Extend parent context values and middleware.\n    const extendedConfig = useMemo(()=>isFunctionalConfig ? config : mergeConfigs(parentConfig, config), [\n        isFunctionalConfig,\n        parentConfig,\n        config\n    ]);\n    // Should not use the inherited provider.\n    const provider = config && config.provider;\n    // initialize the cache only on first access.\n    const cacheContextRef = useRef(UNDEFINED);\n    if (provider && !cacheContextRef.current) {\n        cacheContextRef.current = initCache(provider(extendedConfig.cache || cache), config);\n    }\n    const cacheContext = cacheContextRef.current;\n    // Override the cache if a new provider is given.\n    if (cacheContext) {\n        extendedConfig.cache = cacheContext[0];\n        extendedConfig.mutate = cacheContext[1];\n    }\n    // Unsubscribe events.\n    useIsomorphicLayoutEffect(()=>{\n        if (cacheContext) {\n            cacheContext[2] && cacheContext[2]();\n            return cacheContext[3];\n        }\n    }, []);\n    return createElement(SWRConfigContext.Provider, mergeObjects(props, {\n        value: extendedConfig\n    }));\n};\n\nconst INFINITE_PREFIX = '$inf$';\n\n// @ts-expect-error\nconst enableDevtools = isWindowDefined && window.__SWR_DEVTOOLS_USE__;\nconst use = enableDevtools ? window.__SWR_DEVTOOLS_USE__ : [];\nconst setupDevTools = ()=>{\n    if (enableDevtools) {\n        // @ts-expect-error\n        window.__SWR_DEVTOOLS_REACT__ = React;\n    }\n};\n\nconst normalize = (args)=>{\n    return isFunction(args[1]) ? [\n        args[0],\n        args[1],\n        args[2] || {}\n    ] : [\n        args[0],\n        null,\n        (args[1] === null ? args[2] : args[1]) || {}\n    ];\n};\n\nconst useSWRConfig = ()=>{\n    return mergeObjects(defaultConfig, useContext(SWRConfigContext));\n};\n\nconst preload = (key_, fetcher)=>{\n    const [key, fnArg] = serialize(key_);\n    const [, , , PRELOAD] = SWRGlobalState.get(cache);\n    // Prevent preload to be called multiple times before used.\n    if (PRELOAD[key]) return PRELOAD[key];\n    const req = fetcher(fnArg);\n    PRELOAD[key] = req;\n    return req;\n};\nconst middleware = (useSWRNext)=>(key_, fetcher_, config)=>{\n        // fetcher might be a sync function, so this should not be an async function\n        const fetcher = fetcher_ && ((...args)=>{\n            const [key] = serialize(key_);\n            const [, , , PRELOAD] = SWRGlobalState.get(cache);\n            if (key.startsWith(INFINITE_PREFIX)) {\n                // we want the infinite fetcher to be called.\n                // handling of the PRELOAD cache happens there.\n                return fetcher_(...args);\n            }\n            const req = PRELOAD[key];\n            if (isUndefined(req)) return fetcher_(...args);\n            delete PRELOAD[key];\n            return req;\n        });\n        return useSWRNext(key_, fetcher, config);\n    };\n\nconst BUILT_IN_MIDDLEWARE = use.concat(middleware);\n\n// It's tricky to pass generic types as parameters, so we just directly override\n// the types here.\nconst withArgs = (hook)=>{\n    return function useSWRArgs(...args) {\n        // Get the default and inherited configuration.\n        const fallbackConfig = useSWRConfig();\n        // Normalize arguments.\n        const [key, fn, _config] = normalize(args);\n        // Merge configurations.\n        const config = mergeConfigs(fallbackConfig, _config);\n        // Apply middleware\n        let next = hook;\n        const { use } = config;\n        const middleware = (use || []).concat(BUILT_IN_MIDDLEWARE);\n        for(let i = middleware.length; i--;){\n            next = middleware[i](next);\n        }\n        return next(key, fn || config.fetcher || null, config);\n    };\n};\n\n// Add a callback function to a list of keyed callback functions and return\n// the unsubscribe function.\nconst subscribeCallback = (key, callbacks, callback)=>{\n    const keyedRevalidators = callbacks[key] || (callbacks[key] = []);\n    keyedRevalidators.push(callback);\n    return ()=>{\n        const index = keyedRevalidators.indexOf(callback);\n        if (index >= 0) {\n            // O(1): faster than splice\n            keyedRevalidators[index] = keyedRevalidators[keyedRevalidators.length - 1];\n            keyedRevalidators.pop();\n        }\n    };\n};\n\n// Create a custom hook with a middleware\nconst withMiddleware = (useSWR, middleware)=>{\n    return (...args)=>{\n        const [key, fn, config] = normalize(args);\n        const uses = (config.use || []).concat(middleware);\n        return useSWR(key, fn, {\n            ...config,\n            use: uses\n        });\n    };\n};\n\nsetupDevTools();\n\nexport { INFINITE_PREFIX, IS_REACT_LEGACY, IS_SERVER, OBJECT, SWRConfig, SWRGlobalState, UNDEFINED, cache, compare, createCacheHelper, defaultConfig, defaultConfigOptions, getTimestamp, hasRequestAnimationFrame, initCache, internalMutate, isDocumentDefined, isFunction, isPromiseLike, isUndefined, isWindowDefined, mergeConfigs, mergeObjects, mutate, noop, normalize, preload, preset, rAF, events as revalidateEvents, serialize, slowConnection, stableHash, subscribeCallback, useIsomorphicLayoutEffect, useSWRConfig, withArgs, withMiddleware };\n","import React, { useState, useRef, useCallback } from 'react';\nimport useSWR, { useSWRConfig } from 'swr';\nimport { IS_REACT_LEGACY, useIsomorphicLayoutEffect, withMiddleware, serialize, mergeObjects, getTimestamp, UNDEFINED } from 'swr/_internal';\n\nconst startTransition = IS_REACT_LEGACY ? (cb)=>{\n    cb();\n} : React.startTransition;\n/**\n * An implementation of state with dependency-tracking.\n */ const useStateWithDeps = (state)=>{\n    const [, rerender] = useState({});\n    const unmountedRef = useRef(false);\n    const stateRef = useRef(state);\n    // If a state property (data, error, or isValidating) is accessed by the render\n    // function, we mark the property as a dependency so if it is updated again\n    // in the future, we trigger a rerender.\n    // This is also known as dependency-tracking.\n    const stateDependenciesRef = useRef({\n        data: false,\n        error: false,\n        isValidating: false\n    });\n    /**\n   * @param payload To change stateRef, pass the values explicitly to setState:\n   * @example\n   * ```js\n   * setState({\n   *   isValidating: false\n   *   data: newData // set data to newData\n   *   error: undefined // set error to undefined\n   * })\n   *\n   * setState({\n   *   isValidating: false\n   *   data: undefined // set data to undefined\n   *   error: err // set error to err\n   * })\n   * ```\n   */ const setState = useCallback((payload)=>{\n        let shouldRerender = false;\n        const currentState = stateRef.current;\n        for(const _ in payload){\n            const k = _;\n            // If the property has changed, update the state and mark rerender as\n            // needed.\n            if (currentState[k] !== payload[k]) {\n                currentState[k] = payload[k];\n                // If the property is accessed by the component, a rerender should be\n                // triggered.\n                if (stateDependenciesRef.current[k]) {\n                    shouldRerender = true;\n                }\n            }\n        }\n        if (shouldRerender && !unmountedRef.current) {\n            rerender({});\n        }\n    }, []);\n    useIsomorphicLayoutEffect(()=>{\n        unmountedRef.current = false;\n        return ()=>{\n            unmountedRef.current = true;\n        };\n    });\n    return [\n        stateRef,\n        stateDependenciesRef.current,\n        setState\n    ];\n};\n\nconst mutation = ()=>(key, fetcher, config = {})=>{\n        const { mutate } = useSWRConfig();\n        const keyRef = useRef(key);\n        const fetcherRef = useRef(fetcher);\n        const configRef = useRef(config);\n        // Ditch all mutation results that happened earlier than this timestamp.\n        const ditchMutationsUntilRef = useRef(0);\n        const [stateRef, stateDependencies, setState] = useStateWithDeps({\n            data: UNDEFINED,\n            error: UNDEFINED,\n            isMutating: false\n        });\n        const currentState = stateRef.current;\n        const trigger = useCallback(async (arg, opts)=>{\n            const [serializedKey, resolvedKey] = serialize(keyRef.current);\n            if (!fetcherRef.current) {\n                throw new Error('Can’t trigger the mutation: missing fetcher.');\n            }\n            if (!serializedKey) {\n                throw new Error('Can’t trigger the mutation: missing key.');\n            }\n            // Disable cache population by default.\n            const options = mergeObjects(mergeObjects({\n                populateCache: false,\n                throwOnError: true\n            }, configRef.current), opts);\n            // Trigger a mutation, and also track the timestamp. Any mutation that happened\n            // earlier this timestamp should be ignored.\n            const mutationStartedAt = getTimestamp();\n            ditchMutationsUntilRef.current = mutationStartedAt;\n            setState({\n                isMutating: true\n            });\n            try {\n                const data = await mutate(serializedKey, fetcherRef.current(resolvedKey, {\n                    arg\n                }), // We must throw the error here so we can catch and update the states.\n                mergeObjects(options, {\n                    throwOnError: true\n                }));\n                // If it's reset after the mutation, we don't broadcast any state change.\n                if (ditchMutationsUntilRef.current <= mutationStartedAt) {\n                    var _options_onSuccess, _options;\n                    startTransition(()=>setState({\n                            data,\n                            isMutating: false,\n                            error: undefined\n                        }));\n                    (_options_onSuccess = (_options = options).onSuccess) == null ? void 0 : _options_onSuccess.call(_options, data, serializedKey, options);\n                }\n                return data;\n            } catch (error) {\n                // If it's reset after the mutation, we don't broadcast any state change\n                // or throw because it's discarded.\n                if (ditchMutationsUntilRef.current <= mutationStartedAt) {\n                    var _options_onError, _options1;\n                    startTransition(()=>setState({\n                            error: error,\n                            isMutating: false\n                        }));\n                    (_options_onError = (_options1 = options).onError) == null ? void 0 : _options_onError.call(_options1, error, serializedKey, options);\n                    if (options.throwOnError) {\n                        throw error;\n                    }\n                }\n            }\n        }, // eslint-disable-next-line react-hooks/exhaustive-deps\n        []);\n        const reset = useCallback(()=>{\n            ditchMutationsUntilRef.current = getTimestamp();\n            setState({\n                data: UNDEFINED,\n                error: UNDEFINED,\n                isMutating: false\n            });\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, []);\n        useIsomorphicLayoutEffect(()=>{\n            keyRef.current = key;\n            fetcherRef.current = fetcher;\n            configRef.current = config;\n        });\n        // We don't return `mutate` here as it can be pretty confusing (e.g. people\n        // calling `mutate` but they actually mean `trigger`).\n        // And also, `mutate` relies on the useSWR hook to exist too.\n        return {\n            trigger,\n            reset,\n            get data () {\n                stateDependencies.data = true;\n                return currentState.data;\n            },\n            get error () {\n                stateDependencies.error = true;\n                return currentState.error;\n            },\n            get isMutating () {\n                stateDependencies.isMutating = true;\n                return currentState.isMutating;\n            }\n        };\n    };\n/**\n * A hook to define and manually trigger remote mutations like POST, PUT, DELETE and PATCH use cases.\n *\n * @link https://swr.vercel.app/docs/mutation\n * @example\n * ```jsx\n * import useSWRMutation from 'swr/mutation'\n *\n * const {\n *   data,\n *   error,\n *   trigger,\n *   reset,\n *   isMutating\n * } = useSWRMutation(key, fetcher, options?)\n * ```\n */ const useSWRMutation = withMiddleware(useSWR, mutation);\n\nexport { useSWRMutation as default };\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export { getId } from '@normy/core';\n\nexport {\n  SWRNormalizerProvider,\n  useSWRNormalizer,\n} from './SWRNormalizerProvider';\nexport { useNormalizedSWRMutation } from './useNormalizedSWRMutation';\n"],"names":["React","createNormalizer","useSWRConfig","SWRConfig","createSwrNormalizer","normalizerConfig","normalizer","mutate","_extends","addMutate","mutateCallback","normalize","setNormalizedData","data","queriesToUpdate","getQueriesToUpdate","forEach","query","queryKey","revalidate","SWRNormalizerContext","createContext","undefined","CacheMap","_Map","_inheritsLoose","_this","_len","arguments","length","args","Array","_key","call","apply","concat","_proto","prototype","addNormalizer","set","key","value","_this$normalizer$norm","_this$normalizer","_this$normalizer2","setQuery","_delete","_this$normalizer3","removeQuery","_wrapNativeSuper","Map","SWRNormalizerProviderInternal","_ref","swrNormalizer","children","_useSWRConfig","useEffect","createElement","Provider","SWRNormalizerProvider","_ref2","swrConfigValue","_React$useState","useState","_React$useState2","map","cacheProvider","clearNormalizedData","provider","useSWRNormalizer","useContext","Error","useSWRMutation","useNormalizedSWRMutation","fetcher","options","k","opts","optimisticData","populateCache","onSuccess","mutationKey","config","_options$normalize","onError","error","rollbackData","getId"],"sourceRoot":""}