{"version":3,"file":"normy-swr.min.js","mappings":"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","sources":["webpack://NormySwr/webpack/universalModuleDefinition","webpack://NormySwr/external umd {\"commonjs\":\"@normy/core\",\"commonjs2\":\"@normy/core\",\"amd\":\"@normy/core\",\"root\":\"Normy\"}","webpack://NormySwr/external umd {\"commonjs\":\"react\",\"commonjs2\":\"react\",\"amd\":\"react\",\"root\":\"React\"}","webpack://NormySwr/external umd {\"commonjs\":\"swr\",\"commonjs2\":\"swr\",\"amd\":\"swr\",\"root\":\"Swr\"}","webpack://NormySwr/webpack/bootstrap","webpack://NormySwr/webpack/runtime/define property getters","webpack://NormySwr/webpack/runtime/hasOwnProperty shorthand","webpack://NormySwr/webpack/runtime/make namespace object","webpack://NormySwr/./src/SWRNormalizerProvider.tsx","webpack://NormySwr/../../node_modules/.pnpm/swr@2.2.4_react@18.2.0/node_modules/swr/_internal/dist/index.mjs","webpack://NormySwr/../../node_modules/.pnpm/swr@2.2.4_react@18.2.0/node_modules/swr/mutation/dist/index.mjs","webpack://NormySwr/./src/useNormalizedSWRMutation.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"@normy/core\"), require(\"react\"), require(\"swr\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"@normy/core\", \"react\", \"swr\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"NormySwr\"] = factory(require(\"@normy/core\"), require(\"react\"), require(\"swr\"));\n\telse\n\t\troot[\"NormySwr\"] = factory(root[\"Normy\"], root[\"React\"], root[\"Swr\"]);\n})(self, (__WEBPACK_EXTERNAL_MODULE__700__, __WEBPACK_EXTERNAL_MODULE__359__, __WEBPACK_EXTERNAL_MODULE__115__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__700__;","module.exports = __WEBPACK_EXTERNAL_MODULE__359__;","module.exports = __WEBPACK_EXTERNAL_MODULE__115__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import * as React from 'react';\nimport {\n  type NormalizerConfig,\n  createNormalizer,\n  type Data,\n} from '@normy/core';\nimport { useSWRConfig, SWRConfig, type Key } from 'swr';\n\nconst createSwrNormalizer = (\n  normalizerConfig: Omit<NormalizerConfig, 'structuralSharing'> & {\n    normalize?: (queryKey: string) => boolean;\n  } = {},\n) => {\n  const normalizer = createNormalizer(normalizerConfig);\n  // we solve chicken egg problem this way, we need normalizer to create swr context, and we cannot have mutate before it is created\n  let mutate: ReturnType<typeof useSWRConfig>['mutate'] | null = null;\n\n  return {\n    ...normalizer,\n    addMutate: (mutateCallback: ReturnType<typeof useSWRConfig>['mutate']) => {\n      mutate = mutateCallback;\n    },\n    normalize: normalizerConfig.normalize,\n    setNormalizedData: (data: Data) => {\n      const queriesToUpdate = normalizer.getQueriesToUpdate(data);\n\n      queriesToUpdate.forEach(query => {\n        void mutate?.(query.queryKey, query.data, {\n          revalidate: false,\n        });\n      });\n    },\n  };\n};\n\nconst SWRNormalizerContext = React.createContext<\n  undefined | ReturnType<typeof createSwrNormalizer>\n>(undefined);\n\nclass CacheMap extends Map {\n  normalizer: ReturnType<typeof createSwrNormalizer> | undefined;\n\n  addNormalizer(normalizer: ReturnType<typeof createSwrNormalizer>) {\n    this.normalizer = normalizer;\n  }\n\n  set(key: string, value: { data?: Data }) {\n    if (value.data && (this.normalizer?.normalize?.(key) ?? true)) {\n      this.normalizer?.setQuery(key, value.data);\n    }\n\n    return super.set(key, value);\n  }\n\n  delete(key: string) {\n    this.normalizer?.removeQuery(key);\n    return super.delete(key);\n  }\n}\n\nconst SWRNormalizerProviderInternal = ({\n  swrNormalizer,\n  children,\n}: {\n  swrNormalizer: ReturnType<typeof createSwrNormalizer>;\n  children: React.ReactNode;\n}) => {\n  const { mutate } = useSWRConfig();\n\n  React.useEffect(() => swrNormalizer.addMutate(mutate), []);\n\n  return (\n    <SWRNormalizerContext.Provider value={swrNormalizer}>\n      {children}\n    </SWRNormalizerContext.Provider>\n  );\n};\n\nexport const SWRNormalizerProvider = ({\n  normalizerConfig,\n  swrConfigValue,\n  children,\n}: {\n  normalizerConfig?: Omit<NormalizerConfig, 'structuralSharing'> & {\n    normalize: (queryKey: Key) => boolean;\n  };\n  swrConfigValue: React.ComponentProps<typeof SWRConfig>['value'];\n  children: React.ReactNode;\n}) => {\n  const [swrNormalizer] = React.useState(() =>\n    createSwrNormalizer(normalizerConfig),\n  );\n\n  const [cacheProvider] = React.useState(() => () => {\n    const map = new CacheMap();\n    map.addNormalizer(swrNormalizer);\n    return map;\n  });\n\n  React.useEffect(() => () => swrNormalizer.clearNormalizedData(), []);\n\n  return (\n    <SWRConfig\n      value={{\n        ...swrConfigValue,\n        provider: cacheProvider,\n      }}\n    >\n      <SWRNormalizerProviderInternal swrNormalizer={swrNormalizer}>\n        {children}\n      </SWRNormalizerProviderInternal>\n    </SWRConfig>\n  );\n};\n\nexport const useSWRNormalizer = () => {\n  const swrNormalizer = React.useContext(SWRNormalizerContext);\n\n  if (!swrNormalizer) {\n    throw new Error(\n      'No SWRNormalizer set, use SWRNormalizerProvider to set one',\n    );\n  }\n\n  return swrNormalizer;\n};\n","import React, { useEffect, useLayoutEffect, createContext, useContext, useMemo, useRef, createElement } from 'react';\n\n// Shared state between server components and client components\nconst noop = ()=>{};\n// Using noop() as the undefined value as undefined can be replaced\n// by something else. Prettier ignore and extra parentheses are necessary here\n// to ensure that tsc doesn't remove the __NOINLINE__ comment.\n// prettier-ignore\nconst UNDEFINED = /*#__NOINLINE__*/ noop();\nconst OBJECT = Object;\nconst isUndefined = (v)=>v === UNDEFINED;\nconst isFunction = (v)=>typeof v == 'function';\nconst mergeObjects = (a, b)=>({\n        ...a,\n        ...b\n    });\nconst isPromiseLike = (x)=>isFunction(x.then);\n\n// use WeakMap to store the object->key mapping\n// so the objects can be garbage collected.\n// WeakMap uses a hashtable under the hood, so the lookup\n// complexity is almost O(1).\nconst table = new WeakMap();\n// counter of the key\nlet counter = 0;\n// A stable hash implementation that supports:\n// - Fast and ensures unique hash properties\n// - Handles unserializable values\n// - Handles object key ordering\n// - Generates short results\n//\n// This is not a serialization function, and the result is not guaranteed to be\n// parsable.\nconst stableHash = (arg)=>{\n    const type = typeof arg;\n    const constructor = arg && arg.constructor;\n    const isDate = constructor == Date;\n    let result;\n    let index;\n    if (OBJECT(arg) === arg && !isDate && constructor != RegExp) {\n        // Object/function, not null/date/regexp. Use WeakMap to store the id first.\n        // If it's already hashed, directly return the result.\n        result = table.get(arg);\n        if (result) return result;\n        // Store the hash first for circular reference detection before entering the\n        // recursive `stableHash` calls.\n        // For other objects like set and map, we use this id directly as the hash.\n        result = ++counter + '~';\n        table.set(arg, result);\n        if (constructor == Array) {\n            // Array.\n            result = '@';\n            for(index = 0; index < arg.length; index++){\n                result += stableHash(arg[index]) + ',';\n            }\n            table.set(arg, result);\n        }\n        if (constructor == OBJECT) {\n            // Object, sort keys.\n            result = '#';\n            const keys = OBJECT.keys(arg).sort();\n            while(!isUndefined(index = keys.pop())){\n                if (!isUndefined(arg[index])) {\n                    result += index + ':' + stableHash(arg[index]) + ',';\n                }\n            }\n            table.set(arg, result);\n        }\n    } else {\n        result = isDate ? arg.toJSON() : type == 'symbol' ? arg.toString() : type == 'string' ? JSON.stringify(arg) : '' + arg;\n    }\n    return result;\n};\n\n// Global state used to deduplicate requests and store listeners\nconst SWRGlobalState = new WeakMap();\n\nconst EMPTY_CACHE = {};\nconst INITIAL_CACHE = {};\nconst STR_UNDEFINED = 'undefined';\n// NOTE: Use the function to guarantee it's re-evaluated between jsdom and node runtime for tests.\nconst isWindowDefined = typeof window != STR_UNDEFINED;\nconst isDocumentDefined = typeof document != STR_UNDEFINED;\nconst hasRequestAnimationFrame = ()=>isWindowDefined && typeof window['requestAnimationFrame'] != STR_UNDEFINED;\nconst createCacheHelper = (cache, key)=>{\n    const state = SWRGlobalState.get(cache);\n    return [\n        // Getter\n        ()=>!isUndefined(key) && cache.get(key) || EMPTY_CACHE,\n        // Setter\n        (info)=>{\n            if (!isUndefined(key)) {\n                const prev = cache.get(key);\n                // Before writing to the store, we keep the value in the initial cache\n                // if it's not there yet.\n                if (!(key in INITIAL_CACHE)) {\n                    INITIAL_CACHE[key] = prev;\n                }\n                state[5](key, mergeObjects(prev, info), prev || EMPTY_CACHE);\n            }\n        },\n        // Subscriber\n        state[6],\n        // Get server cache snapshot\n        ()=>{\n            if (!isUndefined(key)) {\n                // If the cache was updated on the client, we return the stored initial value.\n                if (key in INITIAL_CACHE) return INITIAL_CACHE[key];\n            }\n            // If we haven't done any client-side updates, we return the current value.\n            return !isUndefined(key) && cache.get(key) || EMPTY_CACHE;\n        }\n    ];\n} // export { UNDEFINED, OBJECT, isUndefined, isFunction, mergeObjects, isPromiseLike }\n;\n\n/**\n * Due to the bug https://bugs.chromium.org/p/chromium/issues/detail?id=678075,\n * it's not reliable to detect if the browser is currently online or offline\n * based on `navigator.onLine`.\n * As a workaround, we always assume it's online on the first load, and change\n * the status upon `online` or `offline` events.\n */ let online = true;\nconst isOnline = ()=>online;\n// For node and React Native, `add/removeEventListener` doesn't exist on window.\nconst [onWindowEvent, offWindowEvent] = isWindowDefined && window.addEventListener ? [\n    window.addEventListener.bind(window),\n    window.removeEventListener.bind(window)\n] : [\n    noop,\n    noop\n];\nconst isVisible = ()=>{\n    const visibilityState = isDocumentDefined && document.visibilityState;\n    return isUndefined(visibilityState) || visibilityState !== 'hidden';\n};\nconst initFocus = (callback)=>{\n    // focus revalidate\n    if (isDocumentDefined) {\n        document.addEventListener('visibilitychange', callback);\n    }\n    onWindowEvent('focus', callback);\n    return ()=>{\n        if (isDocumentDefined) {\n            document.removeEventListener('visibilitychange', callback);\n        }\n        offWindowEvent('focus', callback);\n    };\n};\nconst initReconnect = (callback)=>{\n    // revalidate on reconnected\n    const onOnline = ()=>{\n        online = true;\n        callback();\n    };\n    // nothing to revalidate, just update the status\n    const onOffline = ()=>{\n        online = false;\n    };\n    onWindowEvent('online', onOnline);\n    onWindowEvent('offline', onOffline);\n    return ()=>{\n        offWindowEvent('online', onOnline);\n        offWindowEvent('offline', onOffline);\n    };\n};\nconst preset = {\n    isOnline,\n    isVisible\n};\nconst defaultConfigOptions = {\n    initFocus,\n    initReconnect\n};\n\nconst IS_REACT_LEGACY = !React.useId;\nconst IS_SERVER = !isWindowDefined || 'Deno' in window;\n// Polyfill requestAnimationFrame\nconst rAF = (f)=>hasRequestAnimationFrame() ? window['requestAnimationFrame'](f) : setTimeout(f, 1);\n// React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser.\nconst useIsomorphicLayoutEffect = IS_SERVER ? useEffect : useLayoutEffect;\n// This assignment is to extend the Navigator type to use effectiveType.\nconst navigatorConnection = typeof navigator !== 'undefined' && navigator.connection;\n// Adjust the config based on slow connection status (<= 70Kbps).\nconst slowConnection = !IS_SERVER && navigatorConnection && ([\n    'slow-2g',\n    '2g'\n].includes(navigatorConnection.effectiveType) || navigatorConnection.saveData);\n\nconst serialize = (key)=>{\n    if (isFunction(key)) {\n        try {\n            key = key();\n        } catch (err) {\n            // dependencies not ready\n            key = '';\n        }\n    }\n    // Use the original key as the argument of fetcher. This can be a string or an\n    // array of values.\n    const args = key;\n    // If key is not falsy, or not an empty array, hash it.\n    key = typeof key == 'string' ? key : (Array.isArray(key) ? key.length : key) ? stableHash(key) : '';\n    return [\n        key,\n        args\n    ];\n};\n\n// Global timestamp.\nlet __timestamp = 0;\nconst getTimestamp = ()=>++__timestamp;\n\nconst FOCUS_EVENT = 0;\nconst RECONNECT_EVENT = 1;\nconst MUTATE_EVENT = 2;\nconst ERROR_REVALIDATE_EVENT = 3;\n\nvar events = {\n  __proto__: null,\n  ERROR_REVALIDATE_EVENT: ERROR_REVALIDATE_EVENT,\n  FOCUS_EVENT: FOCUS_EVENT,\n  MUTATE_EVENT: MUTATE_EVENT,\n  RECONNECT_EVENT: RECONNECT_EVENT\n};\n\nasync function internalMutate(...args) {\n    const [cache, _key, _data, _opts] = args;\n    // When passing as a boolean, it's explicitly used to disable/enable\n    // revalidation.\n    const options = mergeObjects({\n        populateCache: true,\n        throwOnError: true\n    }, typeof _opts === 'boolean' ? {\n        revalidate: _opts\n    } : _opts || {});\n    let populateCache = options.populateCache;\n    const rollbackOnErrorOption = options.rollbackOnError;\n    let optimisticData = options.optimisticData;\n    const revalidate = options.revalidate !== false;\n    const rollbackOnError = (error)=>{\n        return typeof rollbackOnErrorOption === 'function' ? rollbackOnErrorOption(error) : rollbackOnErrorOption !== false;\n    };\n    const throwOnError = options.throwOnError;\n    // If the second argument is a key filter, return the mutation results for all\n    // filtered keys.\n    if (isFunction(_key)) {\n        const keyFilter = _key;\n        const matchedKeys = [];\n        const it = cache.keys();\n        for (const key of it){\n            if (// Skip the special useSWRInfinite and useSWRSubscription keys.\n            !/^\\$(inf|sub)\\$/.test(key) && keyFilter(cache.get(key)._k)) {\n                matchedKeys.push(key);\n            }\n        }\n        return Promise.all(matchedKeys.map(mutateByKey));\n    }\n    return mutateByKey(_key);\n    async function mutateByKey(_k) {\n        // Serialize key\n        const [key] = serialize(_k);\n        if (!key) return;\n        const [get, set] = createCacheHelper(cache, key);\n        const [EVENT_REVALIDATORS, MUTATION, FETCH, PRELOAD] = SWRGlobalState.get(cache);\n        const startRevalidate = ()=>{\n            const revalidators = EVENT_REVALIDATORS[key];\n            if (revalidate) {\n                // Invalidate the key by deleting the concurrent request markers so new\n                // requests will not be deduped.\n                delete FETCH[key];\n                delete PRELOAD[key];\n                if (revalidators && revalidators[0]) {\n                    return revalidators[0](MUTATE_EVENT).then(()=>get().data);\n                }\n            }\n            return get().data;\n        };\n        // If there is no new data provided, revalidate the key with current state.\n        if (args.length < 3) {\n            // Revalidate and broadcast state.\n            return startRevalidate();\n        }\n        let data = _data;\n        let error;\n        // Update global timestamps.\n        const beforeMutationTs = getTimestamp();\n        MUTATION[key] = [\n            beforeMutationTs,\n            0\n        ];\n        const hasOptimisticData = !isUndefined(optimisticData);\n        const state = get();\n        // `displayedData` is the current value on screen. It could be the optimistic value\n        // that is going to be overridden by a `committedData`, or get reverted back.\n        // `committedData` is the validated value that comes from a fetch or mutation.\n        const displayedData = state.data;\n        const currentData = state._c;\n        const committedData = isUndefined(currentData) ? displayedData : currentData;\n        // Do optimistic data update.\n        if (hasOptimisticData) {\n            optimisticData = isFunction(optimisticData) ? optimisticData(committedData, displayedData) : optimisticData;\n            // When we set optimistic data, backup the current committedData data in `_c`.\n            set({\n                data: optimisticData,\n                _c: committedData\n            });\n        }\n        if (isFunction(data)) {\n            // `data` is a function, call it passing current cache value.\n            try {\n                data = data(committedData);\n            } catch (err) {\n                // If it throws an error synchronously, we shouldn't update the cache.\n                error = err;\n            }\n        }\n        // `data` is a promise/thenable, resolve the final data first.\n        if (data && isPromiseLike(data)) {\n            // This means that the mutation is async, we need to check timestamps to\n            // avoid race conditions.\n            data = await data.catch((err)=>{\n                error = err;\n            });\n            // Check if other mutations have occurred since we've started this mutation.\n            // If there's a race we don't update cache or broadcast the change,\n            // just return the data.\n            if (beforeMutationTs !== MUTATION[key][0]) {\n                if (error) throw error;\n                return data;\n            } else if (error && hasOptimisticData && rollbackOnError(error)) {\n                // Rollback. Always populate the cache in this case but without\n                // transforming the data.\n                populateCache = true;\n                // Reset data to be the latest committed data, and clear the `_c` value.\n                set({\n                    data: committedData,\n                    _c: UNDEFINED\n                });\n            }\n        }\n        // If we should write back the cache after request.\n        if (populateCache) {\n            if (!error) {\n                // Transform the result into data.\n                if (isFunction(populateCache)) {\n                    const populateCachedData = populateCache(data, committedData);\n                    set({\n                        data: populateCachedData,\n                        error: UNDEFINED,\n                        _c: UNDEFINED\n                    });\n                } else {\n                    // Only update cached data and reset the error if there's no error. Data can be `undefined` here.\n                    set({\n                        data,\n                        error: UNDEFINED,\n                        _c: UNDEFINED\n                    });\n                }\n            }\n        }\n        // Reset the timestamp to mark the mutation has ended.\n        MUTATION[key][1] = getTimestamp();\n        // Update existing SWR Hooks' internal states:\n        Promise.resolve(startRevalidate()).then(()=>{\n            // The mutation and revalidation are ended, we can clear it since the data is\n            // not an optimistic value anymore.\n            set({\n                _c: UNDEFINED\n            });\n        });\n        // Throw error or return data\n        if (error) {\n            if (throwOnError) throw error;\n            return;\n        }\n        return data;\n    }\n}\n\nconst revalidateAllKeys = (revalidators, type)=>{\n    for(const key in revalidators){\n        if (revalidators[key][0]) revalidators[key][0](type);\n    }\n};\nconst initCache = (provider, options)=>{\n    // The global state for a specific provider will be used to deduplicate\n    // requests and store listeners. As well as a mutate function that is bound to\n    // the cache.\n    // The provider's global state might be already initialized. Let's try to get the\n    // global state associated with the provider first.\n    if (!SWRGlobalState.has(provider)) {\n        const opts = mergeObjects(defaultConfigOptions, options);\n        // If there's no global state bound to the provider, create a new one with the\n        // new mutate function.\n        const EVENT_REVALIDATORS = {};\n        const mutate = internalMutate.bind(UNDEFINED, provider);\n        let unmount = noop;\n        const subscriptions = {};\n        const subscribe = (key, callback)=>{\n            const subs = subscriptions[key] || [];\n            subscriptions[key] = subs;\n            subs.push(callback);\n            return ()=>subs.splice(subs.indexOf(callback), 1);\n        };\n        const setter = (key, value, prev)=>{\n            provider.set(key, value);\n            const subs = subscriptions[key];\n            if (subs) {\n                for (const fn of subs){\n                    fn(value, prev);\n                }\n            }\n        };\n        const initProvider = ()=>{\n            if (!SWRGlobalState.has(provider)) {\n                // Update the state if it's new, or if the provider has been extended.\n                SWRGlobalState.set(provider, [\n                    EVENT_REVALIDATORS,\n                    {},\n                    {},\n                    {},\n                    mutate,\n                    setter,\n                    subscribe\n                ]);\n                if (!IS_SERVER) {\n                    // When listening to the native events for auto revalidations,\n                    // we intentionally put a delay (setTimeout) here to make sure they are\n                    // fired after immediate JavaScript executions, which can be\n                    // React's state updates.\n                    // This avoids some unnecessary revalidations such as\n                    // https://github.com/vercel/swr/issues/1680.\n                    const releaseFocus = opts.initFocus(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, FOCUS_EVENT)));\n                    const releaseReconnect = opts.initReconnect(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, RECONNECT_EVENT)));\n                    unmount = ()=>{\n                        releaseFocus && releaseFocus();\n                        releaseReconnect && releaseReconnect();\n                        // When un-mounting, we need to remove the cache provider from the state\n                        // storage too because it's a side-effect. Otherwise, when re-mounting we\n                        // will not re-register those event listeners.\n                        SWRGlobalState.delete(provider);\n                    };\n                }\n            }\n        };\n        initProvider();\n        // This is a new provider, we need to initialize it and setup DOM events\n        // listeners for `focus` and `reconnect` actions.\n        // We might want to inject an extra layer on top of `provider` in the future,\n        // such as key serialization, auto GC, etc.\n        // For now, it's just a `Map` interface without any modifications.\n        return [\n            provider,\n            mutate,\n            initProvider,\n            unmount\n        ];\n    }\n    return [\n        provider,\n        SWRGlobalState.get(provider)[4]\n    ];\n};\n\n// error retry\nconst onErrorRetry = (_, __, config, revalidate, opts)=>{\n    const maxRetryCount = config.errorRetryCount;\n    const currentRetryCount = opts.retryCount;\n    // Exponential backoff\n    const timeout = ~~((Math.random() + 0.5) * (1 << (currentRetryCount < 8 ? currentRetryCount : 8))) * config.errorRetryInterval;\n    if (!isUndefined(maxRetryCount) && currentRetryCount > maxRetryCount) {\n        return;\n    }\n    setTimeout(revalidate, timeout, opts);\n};\nconst compare = (currentData, newData)=>stableHash(currentData) == stableHash(newData);\n// Default cache provider\nconst [cache, mutate] = initCache(new Map());\n// Default config\nconst defaultConfig = mergeObjects({\n    // events\n    onLoadingSlow: noop,\n    onSuccess: noop,\n    onError: noop,\n    onErrorRetry,\n    onDiscarded: noop,\n    // switches\n    revalidateOnFocus: true,\n    revalidateOnReconnect: true,\n    revalidateIfStale: true,\n    shouldRetryOnError: true,\n    // timeouts\n    errorRetryInterval: slowConnection ? 10000 : 5000,\n    focusThrottleInterval: 5 * 1000,\n    dedupingInterval: 2 * 1000,\n    loadingTimeout: slowConnection ? 5000 : 3000,\n    // providers\n    compare,\n    isPaused: ()=>false,\n    cache,\n    mutate,\n    fallback: {}\n}, // use web preset by default\npreset);\n\nconst mergeConfigs = (a, b)=>{\n    // Need to create a new object to avoid mutating the original here.\n    const v = mergeObjects(a, b);\n    // If two configs are provided, merge their `use` and `fallback` options.\n    if (b) {\n        const { use: u1, fallback: f1 } = a;\n        const { use: u2, fallback: f2 } = b;\n        if (u1 && u2) {\n            v.use = u1.concat(u2);\n        }\n        if (f1 && f2) {\n            v.fallback = mergeObjects(f1, f2);\n        }\n    }\n    return v;\n};\n\nconst SWRConfigContext = createContext({});\nconst SWRConfig = (props)=>{\n    const { value } = props;\n    const parentConfig = useContext(SWRConfigContext);\n    const isFunctionalConfig = isFunction(value);\n    const config = useMemo(()=>isFunctionalConfig ? value(parentConfig) : value, [\n        isFunctionalConfig,\n        parentConfig,\n        value\n    ]);\n    // Extend parent context values and middleware.\n    const extendedConfig = useMemo(()=>isFunctionalConfig ? config : mergeConfigs(parentConfig, config), [\n        isFunctionalConfig,\n        parentConfig,\n        config\n    ]);\n    // Should not use the inherited provider.\n    const provider = config && config.provider;\n    // initialize the cache only on first access.\n    const cacheContextRef = useRef(UNDEFINED);\n    if (provider && !cacheContextRef.current) {\n        cacheContextRef.current = initCache(provider(extendedConfig.cache || cache), config);\n    }\n    const cacheContext = cacheContextRef.current;\n    // Override the cache if a new provider is given.\n    if (cacheContext) {\n        extendedConfig.cache = cacheContext[0];\n        extendedConfig.mutate = cacheContext[1];\n    }\n    // Unsubscribe events.\n    useIsomorphicLayoutEffect(()=>{\n        if (cacheContext) {\n            cacheContext[2] && cacheContext[2]();\n            return cacheContext[3];\n        }\n    }, []);\n    return createElement(SWRConfigContext.Provider, mergeObjects(props, {\n        value: extendedConfig\n    }));\n};\n\nconst INFINITE_PREFIX = '$inf$';\n\n// @ts-expect-error\nconst enableDevtools = isWindowDefined && window.__SWR_DEVTOOLS_USE__;\nconst use = enableDevtools ? window.__SWR_DEVTOOLS_USE__ : [];\nconst setupDevTools = ()=>{\n    if (enableDevtools) {\n        // @ts-expect-error\n        window.__SWR_DEVTOOLS_REACT__ = React;\n    }\n};\n\nconst normalize = (args)=>{\n    return isFunction(args[1]) ? [\n        args[0],\n        args[1],\n        args[2] || {}\n    ] : [\n        args[0],\n        null,\n        (args[1] === null ? args[2] : args[1]) || {}\n    ];\n};\n\nconst useSWRConfig = ()=>{\n    return mergeObjects(defaultConfig, useContext(SWRConfigContext));\n};\n\nconst preload = (key_, fetcher)=>{\n    const [key, fnArg] = serialize(key_);\n    const [, , , PRELOAD] = SWRGlobalState.get(cache);\n    // Prevent preload to be called multiple times before used.\n    if (PRELOAD[key]) return PRELOAD[key];\n    const req = fetcher(fnArg);\n    PRELOAD[key] = req;\n    return req;\n};\nconst middleware = (useSWRNext)=>(key_, fetcher_, config)=>{\n        // fetcher might be a sync function, so this should not be an async function\n        const fetcher = fetcher_ && ((...args)=>{\n            const [key] = serialize(key_);\n            const [, , , PRELOAD] = SWRGlobalState.get(cache);\n            if (key.startsWith(INFINITE_PREFIX)) {\n                // we want the infinite fetcher to be called.\n                // handling of the PRELOAD cache happens there.\n                return fetcher_(...args);\n            }\n            const req = PRELOAD[key];\n            if (isUndefined(req)) return fetcher_(...args);\n            delete PRELOAD[key];\n            return req;\n        });\n        return useSWRNext(key_, fetcher, config);\n    };\n\nconst BUILT_IN_MIDDLEWARE = use.concat(middleware);\n\n// It's tricky to pass generic types as parameters, so we just directly override\n// the types here.\nconst withArgs = (hook)=>{\n    return function useSWRArgs(...args) {\n        // Get the default and inherited configuration.\n        const fallbackConfig = useSWRConfig();\n        // Normalize arguments.\n        const [key, fn, _config] = normalize(args);\n        // Merge configurations.\n        const config = mergeConfigs(fallbackConfig, _config);\n        // Apply middleware\n        let next = hook;\n        const { use } = config;\n        const middleware = (use || []).concat(BUILT_IN_MIDDLEWARE);\n        for(let i = middleware.length; i--;){\n            next = middleware[i](next);\n        }\n        return next(key, fn || config.fetcher || null, config);\n    };\n};\n\n// Add a callback function to a list of keyed callback functions and return\n// the unsubscribe function.\nconst subscribeCallback = (key, callbacks, callback)=>{\n    const keyedRevalidators = callbacks[key] || (callbacks[key] = []);\n    keyedRevalidators.push(callback);\n    return ()=>{\n        const index = keyedRevalidators.indexOf(callback);\n        if (index >= 0) {\n            // O(1): faster than splice\n            keyedRevalidators[index] = keyedRevalidators[keyedRevalidators.length - 1];\n            keyedRevalidators.pop();\n        }\n    };\n};\n\n// Create a custom hook with a middleware\nconst withMiddleware = (useSWR, middleware)=>{\n    return (...args)=>{\n        const [key, fn, config] = normalize(args);\n        const uses = (config.use || []).concat(middleware);\n        return useSWR(key, fn, {\n            ...config,\n            use: uses\n        });\n    };\n};\n\nsetupDevTools();\n\nexport { INFINITE_PREFIX, IS_REACT_LEGACY, IS_SERVER, OBJECT, SWRConfig, SWRGlobalState, UNDEFINED, cache, compare, createCacheHelper, defaultConfig, defaultConfigOptions, getTimestamp, hasRequestAnimationFrame, initCache, internalMutate, isDocumentDefined, isFunction, isPromiseLike, isUndefined, isWindowDefined, mergeConfigs, mergeObjects, mutate, noop, normalize, preload, preset, rAF, events as revalidateEvents, serialize, slowConnection, stableHash, subscribeCallback, useIsomorphicLayoutEffect, useSWRConfig, withArgs, withMiddleware };\n","import React, { useState, useRef, useCallback } from 'react';\nimport useSWR, { useSWRConfig } from 'swr';\nimport { IS_REACT_LEGACY, useIsomorphicLayoutEffect, withMiddleware, serialize, mergeObjects, getTimestamp, UNDEFINED } from 'swr/_internal';\n\nconst startTransition = IS_REACT_LEGACY ? (cb)=>{\n    cb();\n} : React.startTransition;\n/**\n * An implementation of state with dependency-tracking.\n */ const useStateWithDeps = (state)=>{\n    const [, rerender] = useState({});\n    const unmountedRef = useRef(false);\n    const stateRef = useRef(state);\n    // If a state property (data, error, or isValidating) is accessed by the render\n    // function, we mark the property as a dependency so if it is updated again\n    // in the future, we trigger a rerender.\n    // This is also known as dependency-tracking.\n    const stateDependenciesRef = useRef({\n        data: false,\n        error: false,\n        isValidating: false\n    });\n    /**\n   * @param payload To change stateRef, pass the values explicitly to setState:\n   * @example\n   * ```js\n   * setState({\n   *   isValidating: false\n   *   data: newData // set data to newData\n   *   error: undefined // set error to undefined\n   * })\n   *\n   * setState({\n   *   isValidating: false\n   *   data: undefined // set data to undefined\n   *   error: err // set error to err\n   * })\n   * ```\n   */ const setState = useCallback((payload)=>{\n        let shouldRerender = false;\n        const currentState = stateRef.current;\n        for(const _ in payload){\n            const k = _;\n            // If the property has changed, update the state and mark rerender as\n            // needed.\n            if (currentState[k] !== payload[k]) {\n                currentState[k] = payload[k];\n                // If the property is accessed by the component, a rerender should be\n                // triggered.\n                if (stateDependenciesRef.current[k]) {\n                    shouldRerender = true;\n                }\n            }\n        }\n        if (shouldRerender && !unmountedRef.current) {\n            rerender({});\n        }\n    }, []);\n    useIsomorphicLayoutEffect(()=>{\n        unmountedRef.current = false;\n        return ()=>{\n            unmountedRef.current = true;\n        };\n    });\n    return [\n        stateRef,\n        stateDependenciesRef.current,\n        setState\n    ];\n};\n\nconst mutation = ()=>(key, fetcher, config = {})=>{\n        const { mutate } = useSWRConfig();\n        const keyRef = useRef(key);\n        const fetcherRef = useRef(fetcher);\n        const configRef = useRef(config);\n        // Ditch all mutation results that happened earlier than this timestamp.\n        const ditchMutationsUntilRef = useRef(0);\n        const [stateRef, stateDependencies, setState] = useStateWithDeps({\n            data: UNDEFINED,\n            error: UNDEFINED,\n            isMutating: false\n        });\n        const currentState = stateRef.current;\n        const trigger = useCallback(async (arg, opts)=>{\n            const [serializedKey, resolvedKey] = serialize(keyRef.current);\n            if (!fetcherRef.current) {\n                throw new Error('Can’t trigger the mutation: missing fetcher.');\n            }\n            if (!serializedKey) {\n                throw new Error('Can’t trigger the mutation: missing key.');\n            }\n            // Disable cache population by default.\n            const options = mergeObjects(mergeObjects({\n                populateCache: false,\n                throwOnError: true\n            }, configRef.current), opts);\n            // Trigger a mutation, and also track the timestamp. Any mutation that happened\n            // earlier this timestamp should be ignored.\n            const mutationStartedAt = getTimestamp();\n            ditchMutationsUntilRef.current = mutationStartedAt;\n            setState({\n                isMutating: true\n            });\n            try {\n                const data = await mutate(serializedKey, fetcherRef.current(resolvedKey, {\n                    arg\n                }), // We must throw the error here so we can catch and update the states.\n                mergeObjects(options, {\n                    throwOnError: true\n                }));\n                // If it's reset after the mutation, we don't broadcast any state change.\n                if (ditchMutationsUntilRef.current <= mutationStartedAt) {\n                    var _options_onSuccess, _options;\n                    startTransition(()=>setState({\n                            data,\n                            isMutating: false,\n                            error: undefined\n                        }));\n                    (_options_onSuccess = (_options = options).onSuccess) == null ? void 0 : _options_onSuccess.call(_options, data, serializedKey, options);\n                }\n                return data;\n            } catch (error) {\n                // If it's reset after the mutation, we don't broadcast any state change\n                // or throw because it's discarded.\n                if (ditchMutationsUntilRef.current <= mutationStartedAt) {\n                    var _options_onError, _options1;\n                    startTransition(()=>setState({\n                            error: error,\n                            isMutating: false\n                        }));\n                    (_options_onError = (_options1 = options).onError) == null ? void 0 : _options_onError.call(_options1, error, serializedKey, options);\n                    if (options.throwOnError) {\n                        throw error;\n                    }\n                }\n            }\n        }, // eslint-disable-next-line react-hooks/exhaustive-deps\n        []);\n        const reset = useCallback(()=>{\n            ditchMutationsUntilRef.current = getTimestamp();\n            setState({\n                data: UNDEFINED,\n                error: UNDEFINED,\n                isMutating: false\n            });\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, []);\n        useIsomorphicLayoutEffect(()=>{\n            keyRef.current = key;\n            fetcherRef.current = fetcher;\n            configRef.current = config;\n        });\n        // We don't return `mutate` here as it can be pretty confusing (e.g. people\n        // calling `mutate` but they actually mean `trigger`).\n        // And also, `mutate` relies on the useSWR hook to exist too.\n        return {\n            trigger,\n            reset,\n            get data () {\n                stateDependencies.data = true;\n                return currentState.data;\n            },\n            get error () {\n                stateDependencies.error = true;\n                return currentState.error;\n            },\n            get isMutating () {\n                stateDependencies.isMutating = true;\n                return currentState.isMutating;\n            }\n        };\n    };\n/**\n * A hook to define and manually trigger remote mutations like POST, PUT, DELETE and PATCH use cases.\n *\n * @link https://swr.vercel.app/docs/mutation\n * @example\n * ```jsx\n * import useSWRMutation from 'swr/mutation'\n *\n * const {\n *   data,\n *   error,\n *   trigger,\n *   reset,\n *   isMutating\n * } = useSWRMutation(key, fetcher, options?)\n * ```\n */ const useSWRMutation = withMiddleware(useSWR, mutation);\n\nexport { useSWRMutation as default };\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { Data as NormyData } from '@normy/core';\nimport { useSWRConfig, type Key } from 'swr';\nimport useSWRMutation, {\n  type MutationFetcher,\n  type SWRMutationConfiguration,\n  type SWRMutationResponse,\n} from 'swr/mutation';\n\nimport { useSWRNormalizer } from './SWRNormalizerProvider';\n\ntype NormyOptions = {\n  normalize?: boolean;\n  optimisticData?: NormyData;\n  rollbackData?: NormyData;\n};\n\ninterface NormalizedSWRMutationHook {\n  <\n    Data = any,\n    Error = any,\n    SWRMutationKey extends Key = Key,\n    ExtraArg = never,\n    SWRData = Data,\n  >(\n    key: SWRMutationKey,\n    fetcher: MutationFetcher<Data, SWRMutationKey, ExtraArg>,\n    options?: SWRMutationConfiguration<\n      Data,\n      Error,\n      SWRMutationKey,\n      ExtraArg,\n      SWRData\n    > &\n      NormyOptions,\n  ): SWRMutationResponse<Data, Error, SWRMutationKey, ExtraArg>;\n  <\n    Data = any,\n    Error = any,\n    SWRMutationKey extends Key = Key,\n    ExtraArg = never,\n    SWRData = Data,\n  >(\n    key: SWRMutationKey,\n    fetcher: MutationFetcher<Data, SWRMutationKey, ExtraArg>,\n    options?: SWRMutationConfiguration<\n      Data,\n      Error,\n      SWRMutationKey,\n      ExtraArg,\n      SWRData\n    > & { throwOnError: false } & NormyOptions,\n  ): SWRMutationResponse<Data | undefined, Error, SWRMutationKey, ExtraArg>;\n  <\n    Data = any,\n    Error = any,\n    SWRMutationKey extends Key = Key,\n    ExtraArg = never,\n    SWRData = Data,\n  >(\n    key: SWRMutationKey,\n    fetcher: MutationFetcher<Data, SWRMutationKey, ExtraArg>,\n    options?: SWRMutationConfiguration<\n      Data,\n      Error,\n      SWRMutationKey,\n      ExtraArg,\n      SWRData\n    > & { throwOnError: true } & NormyOptions,\n  ): SWRMutationResponse<Data, Error, SWRMutationKey, ExtraArg>;\n}\n\nexport const useNormalizedSWRMutation: NormalizedSWRMutationHook = (\n  key,\n  fetcher,\n  options,\n) => {\n  const { mutate } = useSWRConfig();\n  const normalizer = useSWRNormalizer();\n\n  return useSWRMutation(\n    key,\n    // @ts-expect-error swr types compatiblity issue, perhaps due to ts version mismatch\n    (k, opts) => {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n      if (options?.optimisticData) {\n        const queriesToUpdate = normalizer.getQueriesToUpdate(\n          options?.optimisticData as NormyData,\n        );\n\n        queriesToUpdate.forEach(query => {\n          void mutate(query.queryKey, query.data, {\n            revalidate: false,\n          });\n        });\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n      return fetcher(k, opts);\n    },\n    {\n      populateCache: false,\n      revalidate: false,\n      ...options,\n      optimisticData: undefined,\n      onSuccess: (data, mutationKey, config) => {\n        if (options?.normalize ?? true) {\n          const queriesToUpdate = normalizer.getQueriesToUpdate(\n            data as NormyData,\n          );\n\n          queriesToUpdate.forEach(query => {\n            void mutate(query.queryKey, query.data, {\n              revalidate: false,\n            });\n          });\n        }\n\n        return options?.onSuccess?.(data, mutationKey, config);\n      },\n      onError: (error, mutationKey, config) => {\n        if (options?.rollbackData) {\n          const queriesToUpdate = normalizer.getQueriesToUpdate(\n            options?.rollbackData as NormyData,\n          );\n\n          queriesToUpdate.forEach(query => {\n            void mutate(query.queryKey, query.data, {\n              revalidate: false,\n            });\n          });\n        }\n\n        return options?.onError?.(error, mutationKey, config);\n      },\n    },\n  );\n};\n"],"names":["root","factory","exports","module","require","define","amd","self","__WEBPACK_EXTERNAL_MODULE__700__","__WEBPACK_EXTERNAL_MODULE__359__","__WEBPACK_EXTERNAL_MODULE__115__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","SWRNormalizerContext","React","CacheMap","_Map","_this","_len","arguments","length","args","Array","_key","apply","concat","normalizer","_proto","addNormalizer","this","set","_this$normalizer$norm","_this$normalizer","_this$normalizer2","data","normalize","setQuery","_this$normalizer3","removeQuery","_wrapNativeSuper","Map","SWRNormalizerProviderInternal","_ref","swrNormalizer","children","mutate","useSWRConfig","addMutate","Provider","SWRNormalizerProvider","_ref2","normalizerConfig","swrConfigValue","_React$useState","createNormalizer","_extends","mutateCallback","setNormalizedData","getQueriesToUpdate","forEach","query","queryKey","revalidate","createSwrNormalizer","cacheProvider","map","clearNormalizedData","SWRConfig","provider","useSWRNormalizer","Error","noop","UNDEFINED","OBJECT","isUndefined","v","isFunction","mergeObjects","a","b","table","WeakMap","counter","stableHash","arg","type","constructor","isDate","Date","result","index","RegExp","toJSON","toString","JSON","stringify","keys","sort","pop","SWRGlobalState","EMPTY_CACHE","INITIAL_CACHE","STR_UNDEFINED","isWindowDefined","window","isDocumentDefined","document","online","onWindowEvent","offWindowEvent","addEventListener","bind","removeEventListener","preset","isOnline","isVisible","visibilityState","defaultConfigOptions","initFocus","callback","initReconnect","onOnline","onOffline","IS_REACT_LEGACY","IS_SERVER","useIsomorphicLayoutEffect","useEffect","useLayoutEffect","navigatorConnection","navigator","connection","slowConnection","includes","effectiveType","saveData","serialize","err","isArray","__timestamp","getTimestamp","async","internalMutate","cache","_data","_opts","options","populateCache","throwOnError","rollbackOnErrorOption","rollbackOnError","optimisticData","keyFilter","matchedKeys","it","test","_k","push","Promise","all","mutateByKey","state","info","prev","createCacheHelper","EVENT_REVALIDATORS","MUTATION","FETCH","PRELOAD","startRevalidate","revalidators","then","error","beforeMutationTs","hasOptimisticData","displayedData","currentData","_c","committedData","catch","populateCachedData","resolve","revalidateAllKeys","has","opts","unmount","subscriptions","subscribe","subs","splice","indexOf","setter","fn","initProvider","releaseFocus","setTimeout","releaseReconnect","delete","initCache","enableDevtools","onLoadingSlow","onSuccess","onError","onErrorRetry","_","__","config","maxRetryCount","errorRetryCount","currentRetryCount","retryCount","timeout","Math","random","errorRetryInterval","onDiscarded","revalidateOnFocus","revalidateOnReconnect","revalidateIfStale","shouldRetryOnError","focusThrottleInterval","dedupingInterval","loadingTimeout","compare","newData","isPaused","fallback","createContext","__SWR_DEVTOOLS_USE__","use","useSWRNext","key_","fetcher_","startsWith","req","__SWR_DEVTOOLS_REACT__","startTransition","cb","useSWRMutation","useSWR","middleware","fetcher","keyRef","useRef","fetcherRef","configRef","ditchMutationsUntilRef","stateRef","stateDependencies","setState","rerender","useState","unmountedRef","stateDependenciesRef","isValidating","useCallback","payload","shouldRerender","currentState","current","k","useStateWithDeps","isMutating","trigger","serializedKey","resolvedKey","mutationStartedAt","_options_onSuccess","_options","_options_onError","_options1","reset","uses","useNormalizedSWRMutation","mutationKey","_options$normalize","rollbackData"],"sourceRoot":""}